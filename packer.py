from decimal import Decimal
from typing import List, Tuple

class Item:
    def __init__(self, name: str, width: float, height: float, depth: float, weight: float = 0):
        self.name = name
        self.width = width
        self.height = height
        self.depth = depth
        self.weight = weight
        self.rotation_type = 0
        self.position = [0, 0, 0]
        self.flg_unfitted = False

    def get_dimension(self) -> List[float]:
        # Based on rotation type, return dimensions
        if self.rotation_type == 0: return [self.width, self.height, self.depth]
        elif self.rotation_type == 1: return [self.width, self.depth, self.height]
        elif self.rotation_type == 2: return [self.height, self.width, self.depth]
        elif self.rotation_type == 3: return [self.height, self.depth, self.width]
        elif self.rotation_type == 4: return [self.depth, self.width, self.height]
        elif self.rotation_type == 5: return [self.depth, self.height, self.width]
        return [self.width, self.height, self.depth]

    def get_volume(self) -> float:
        return self.width * self.height * self.depth

    def string(self) -> str:
        return f"{self.name}({self.width}x{self.height}x{self.depth})"

class Bin:
    def __init__(self, name: str, width: float, height: float, depth: float, max_weight: float = 0):
        self.name = name
        self.width = width
        self.height = height
        self.depth = depth
        self.max_weight = max_weight
        self.items: List[Item] = []
        self.unfitted_items: List[Item] = []

    def get_volume(self) -> float:
        return self.width * self.height * self.depth

    def get_total_weight(self) -> float:
        return sum([i.weight for i in self.items])

    def put_item(self, item: Item, pivot: List[float]) -> bool:
        valid_item_position = item.position[:] # Copy
        item.position = pivot[:]
        
        # Check if item fits in bin dimensions
        d = item.get_dimension()
        if (
            pivot[0] + d[0] <= self.width and
            pivot[1] + d[1] <= self.height and
            pivot[2] + d[2] <= self.depth
        ):
            # Check for overlap
            for current_item in self.items:
                if self._intersect(current_item, item):
                    item.position = valid_item_position
                    return False
                    
            if self.max_weight > 0 and self.get_total_weight() + item.weight > self.max_weight:
                item.position = valid_item_position
                return False
                
            self.items.append(item)
            return True
            
        item.position = valid_item_position
        return False

    def _intersect(self, i1: Item, i2: Item) -> bool:
        d1 = i1.get_dimension()
        d2 = i2.get_dimension()
        
        # Check if they do NOT intersect, then negate
        # Standard AABB intersection:
        # box1 right > box2 left AND box1 left < box2 right ...
        
        # projected coordinates
        p1 = i1.position
        p2 = i2.position
        
        return (
            p1[0] < p2[0] + d2[0] and p1[0] + d1[0] > p2[0] and
            p1[1] < p2[1] + d2[1] and p1[1] + d1[1] > p2[1] and
            p1[2] < p2[2] + d2[2] and p1[2] + d1[2] > p2[2]
        )

class Packer:
    def __init__(self):
        self.bins: List[Bin] = []
        self.items: List[Item] = []
        self.unfit_items: List[Item] = []

    def add_bin(self, bin: Bin):
        self.bins.append(bin)

    def add_item(self, item: Item):
        self.items.append(item)

    def pack(self, bigger_first=True, distribute_items=False):
        # Sort bins (smallest first usually, but here we iterate)
        # Sort items
        self.items.sort(key=lambda x: x.get_volume(), reverse=bigger_first)
        self.bins.sort(key=lambda x: x.get_volume(), reverse=False) # Try smallest bin first? Or keep order? Usually fit into first bin that works.

        for item in self.items:
            fitted = False
            for bin in self.bins:
                if distribute_items and fitted:
                    break
                
                # Check 6 rotations
                # This is a simplified 3D bin packing heuristic
                # We try to place the item at every "pivot point" generated by other items
                
                best_orientation = -1
                best_pivot = None
                
                # Available pivots: (0,0,0) initially, then for each item placed:
                # (x+w, y, z), (x, y+h, z), (x, y, z+d)
                
                # Ideally, start with 0,0,0
                # We need a robust way to find candidate positions. 
                # A common heuristic is to try all corners of existing items + (0,0,0)
                
                # But to keep it simple and fast as requested ("First Fit Decreasing"):
                # We iterate through all candidate positions (Pivots)
                # For each pivot, try all 6 rotations.
                
                candidate_pivots = [[0,0,0]]
                for i in bin.items:
                    d = i.get_dimension()
                    candidate_pivots.append([i.position[0] + d[0], i.position[1], i.position[2]]) # Right
                    candidate_pivots.append([i.position[0], i.position[1] + d[1], i.position[2]]) # Top
                    candidate_pivots.append([i.position[0], i.position[1], i.position[2] + d[2]]) # Front
                
                # Sort pivots? Maybe by distance to origin to pack tightly
                candidate_pivots.sort(key=lambda p: p[0]**2 + p[1]**2 + p[2]**2)

                # Remove duplicates
                
                # Try to fit
                bin_fitted = False
                for pivot in candidate_pivots:
                    if bin_fitted: break
                    for rotation in range(6):
                        item.rotation_type = rotation
                        if bin.put_item(item, pivot):
                            bin_fitted = True
                            fitted = True
                            break
                            
                if bin_fitted:
                    break
            
            if not fitted:
                self.unfit_items.append(item)
